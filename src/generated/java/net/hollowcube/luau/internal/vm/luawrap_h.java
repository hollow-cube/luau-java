// Generated by jextract

package net.hollowcube.luau.internal.vm;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class luawrap_h {

    luawrap_h() {
        // Should not be called directly
    }

    static final Arena LIBRARY_ARENA = Arena.ofAuto();
    static final boolean TRACE_DOWNCALLS = Boolean.getBoolean("jextract.trace.downcalls");

    static void traceDowncall(String name, Object... args) {
         String traceArgs = Arrays.stream(args)
                       .map(Object::toString)
                       .collect(Collectors.joining(", "));
         System.out.printf("%s(%s)\n", name, traceArgs);
    }

    static MemorySegment findOrThrow(String symbol) {
        return SYMBOL_LOOKUP.find(symbol)
            .orElseThrow(() -> new UnsatisfiedLinkError("unresolved symbol: " + symbol));
    }

    static MethodHandle upcallHandle(Class<?> fi, String name, FunctionDescriptor fdesc) {
        try {
            return MethodHandles.lookup().findVirtual(fi, name, fdesc.toMethodType());
        } catch (ReflectiveOperationException ex) {
            throw new AssertionError(ex);
        }
    }

    static MemoryLayout align(MemoryLayout layout, long align) {
        return switch (layout) {
            case PaddingLayout p -> p;
            case ValueLayout v -> v.withByteAlignment(align);
            case GroupLayout g -> {
                MemoryLayout[] alignedMembers = g.memberLayouts().stream()
                        .map(m -> align(m, align)).toArray(MemoryLayout[]::new);
                yield g instanceof StructLayout ?
                        MemoryLayout.structLayout(alignedMembers) : MemoryLayout.unionLayout(alignedMembers);
            }
            case SequenceLayout s -> MemoryLayout.sequenceLayout(s.elementCount(), align(s.elementLayout(), align));
        };
    }

    static final SymbolLookup SYMBOL_LOOKUP = SymbolLookup.loaderLookup()
            .or(Linker.nativeLinker().defaultLookup());

    public static final ValueLayout.OfBoolean C_BOOL = ValueLayout.JAVA_BOOLEAN;
    public static final ValueLayout.OfByte C_CHAR = ValueLayout.JAVA_BYTE;
    public static final ValueLayout.OfShort C_SHORT = ValueLayout.JAVA_SHORT;
    public static final ValueLayout.OfInt C_INT = ValueLayout.JAVA_INT;
    public static final ValueLayout.OfLong C_LONG_LONG = ValueLayout.JAVA_LONG;
    public static final ValueLayout.OfFloat C_FLOAT = ValueLayout.JAVA_FLOAT;
    public static final ValueLayout.OfDouble C_DOUBLE = ValueLayout.JAVA_DOUBLE;
    public static final AddressLayout C_POINTER = ValueLayout.ADDRESS
            .withTargetLayout(MemoryLayout.sequenceLayout(java.lang.Long.MAX_VALUE, JAVA_BYTE));
    public static final ValueLayout.OfLong C_LONG = ValueLayout.JAVA_LONG;

    private static class lua_xmove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            luawrap_h.C_POINTER,
            luawrap_h.C_POINTER,
            luawrap_h.C_INT
        );

        public static final MemorySegment ADDR = luawrap_h.findOrThrow("lua_xmove");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void lua_xmove(lua_State *from, lua_State *to, int n)
     * }
     */
    public static FunctionDescriptor lua_xmove$descriptor() {
        return lua_xmove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void lua_xmove(lua_State *from, lua_State *to, int n)
     * }
     */
    public static MethodHandle lua_xmove$handle() {
        return lua_xmove.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void lua_xmove(lua_State *from, lua_State *to, int n)
     * }
     */
    public static MemorySegment lua_xmove$address() {
        return lua_xmove.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void lua_xmove(lua_State *from, lua_State *to, int n)
     * }
     */
    public static void lua_xmove(MemorySegment from, MemorySegment to, int n) {
        var mh$ = lua_xmove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_xmove", from, to, n);
            }
            mh$.invokeExact(from, to, n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_xpush {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            luawrap_h.C_POINTER,
            luawrap_h.C_POINTER,
            luawrap_h.C_INT
        );

        public static final MemorySegment ADDR = luawrap_h.findOrThrow("lua_xpush");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void lua_xpush(lua_State *from, lua_State *to, int idx)
     * }
     */
    public static FunctionDescriptor lua_xpush$descriptor() {
        return lua_xpush.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void lua_xpush(lua_State *from, lua_State *to, int idx)
     * }
     */
    public static MethodHandle lua_xpush$handle() {
        return lua_xpush.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void lua_xpush(lua_State *from, lua_State *to, int idx)
     * }
     */
    public static MemorySegment lua_xpush$address() {
        return lua_xpush.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void lua_xpush(lua_State *from, lua_State *to, int idx)
     * }
     */
    public static void lua_xpush(MemorySegment from, MemorySegment to, int idx) {
        var mh$ = lua_xpush.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_xpush", from, to, idx);
            }
            mh$.invokeExact(from, to, idx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaW_getstatus {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luawrap_h.C_INT,
            luawrap_h.C_POINTER
        );

        public static final MemorySegment ADDR = luawrap_h.findOrThrow("luaW_getstatus");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int luaW_getstatus(lua_State *L)
     * }
     */
    public static FunctionDescriptor luaW_getstatus$descriptor() {
        return luaW_getstatus.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int luaW_getstatus(lua_State *L)
     * }
     */
    public static MethodHandle luaW_getstatus$handle() {
        return luaW_getstatus.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int luaW_getstatus(lua_State *L)
     * }
     */
    public static MemorySegment luaW_getstatus$address() {
        return luaW_getstatus.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int luaW_getstatus(lua_State *L)
     * }
     */
    public static int luaW_getstatus(MemorySegment L) {
        var mh$ = luaW_getstatus.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaW_getstatus", L);
            }
            return (int)mh$.invokeExact(L);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaW_newstate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luawrap_h.C_POINTER,
            luawrap_h.C_POINTER
        );

        public static final MemorySegment ADDR = luawrap_h.findOrThrow("luaW_newstate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern lua_State *luaW_newstate(lua_Alloc f)
     * }
     */
    public static FunctionDescriptor luaW_newstate$descriptor() {
        return luaW_newstate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern lua_State *luaW_newstate(lua_Alloc f)
     * }
     */
    public static MethodHandle luaW_newstate$handle() {
        return luaW_newstate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern lua_State *luaW_newstate(lua_Alloc f)
     * }
     */
    public static MemorySegment luaW_newstate$address() {
        return luaW_newstate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern lua_State *luaW_newstate(lua_Alloc f)
     * }
     */
    public static MemorySegment luaW_newstate(MemorySegment f) {
        var mh$ = luaW_newstate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaW_newstate", f);
            }
            return (MemorySegment)mh$.invokeExact(f);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaW_newthread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luawrap_h.C_POINTER,
            luawrap_h.C_POINTER
        );

        public static final MemorySegment ADDR = luawrap_h.findOrThrow("luaW_newthread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern lua_State *luaW_newthread(lua_State *L)
     * }
     */
    public static FunctionDescriptor luaW_newthread$descriptor() {
        return luaW_newthread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern lua_State *luaW_newthread(lua_State *L)
     * }
     */
    public static MethodHandle luaW_newthread$handle() {
        return luaW_newthread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern lua_State *luaW_newthread(lua_State *L)
     * }
     */
    public static MemorySegment luaW_newthread$address() {
        return luaW_newthread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern lua_State *luaW_newthread(lua_State *L)
     * }
     */
    public static MemorySegment luaW_newthread(MemorySegment L) {
        var mh$ = luaW_newthread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaW_newthread", L);
            }
            return (MemorySegment)mh$.invokeExact(L);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaW_resetthread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            luawrap_h.C_POINTER
        );

        public static final MemorySegment ADDR = luawrap_h.findOrThrow("luaW_resetthread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void luaW_resetthread(lua_State *L)
     * }
     */
    public static FunctionDescriptor luaW_resetthread$descriptor() {
        return luaW_resetthread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void luaW_resetthread(lua_State *L)
     * }
     */
    public static MethodHandle luaW_resetthread$handle() {
        return luaW_resetthread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void luaW_resetthread(lua_State *L)
     * }
     */
    public static MemorySegment luaW_resetthread$address() {
        return luaW_resetthread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void luaW_resetthread(lua_State *L)
     * }
     */
    public static void luaW_resetthread(MemorySegment L) {
        var mh$ = luaW_resetthread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaW_resetthread", L);
            }
            mh$.invokeExact(L);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaW_equal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luawrap_h.C_INT,
            luawrap_h.C_POINTER,
            luawrap_h.C_INT,
            luawrap_h.C_INT
        );

        public static final MemorySegment ADDR = luawrap_h.findOrThrow("luaW_equal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int luaW_equal(lua_State *L, int idx1, int idx2)
     * }
     */
    public static FunctionDescriptor luaW_equal$descriptor() {
        return luaW_equal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int luaW_equal(lua_State *L, int idx1, int idx2)
     * }
     */
    public static MethodHandle luaW_equal$handle() {
        return luaW_equal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int luaW_equal(lua_State *L, int idx1, int idx2)
     * }
     */
    public static MemorySegment luaW_equal$address() {
        return luaW_equal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int luaW_equal(lua_State *L, int idx1, int idx2)
     * }
     */
    public static int luaW_equal(MemorySegment L, int idx1, int idx2) {
        var mh$ = luaW_equal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaW_equal", L, idx1, idx2);
            }
            return (int)mh$.invokeExact(L, idx1, idx2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaW_lessthan {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luawrap_h.C_INT,
            luawrap_h.C_POINTER,
            luawrap_h.C_INT,
            luawrap_h.C_INT
        );

        public static final MemorySegment ADDR = luawrap_h.findOrThrow("luaW_lessthan");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int luaW_lessthan(lua_State *L, int idx1, int idx2)
     * }
     */
    public static FunctionDescriptor luaW_lessthan$descriptor() {
        return luaW_lessthan.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int luaW_lessthan(lua_State *L, int idx1, int idx2)
     * }
     */
    public static MethodHandle luaW_lessthan$handle() {
        return luaW_lessthan.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int luaW_lessthan(lua_State *L, int idx1, int idx2)
     * }
     */
    public static MemorySegment luaW_lessthan$address() {
        return luaW_lessthan.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int luaW_lessthan(lua_State *L, int idx1, int idx2)
     * }
     */
    public static int luaW_lessthan(MemorySegment L, int idx1, int idx2) {
        var mh$ = luaW_lessthan.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaW_lessthan", L, idx1, idx2);
            }
            return (int)mh$.invokeExact(L, idx1, idx2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaW_tolstring {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luawrap_h.C_POINTER,
            luawrap_h.C_POINTER,
            luawrap_h.C_INT,
            luawrap_h.C_POINTER
        );

        public static final MemorySegment ADDR = luawrap_h.findOrThrow("luaW_tolstring");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *luaW_tolstring(lua_State *L, int idx, size_t *len)
     * }
     */
    public static FunctionDescriptor luaW_tolstring$descriptor() {
        return luaW_tolstring.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *luaW_tolstring(lua_State *L, int idx, size_t *len)
     * }
     */
    public static MethodHandle luaW_tolstring$handle() {
        return luaW_tolstring.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *luaW_tolstring(lua_State *L, int idx, size_t *len)
     * }
     */
    public static MemorySegment luaW_tolstring$address() {
        return luaW_tolstring.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *luaW_tolstring(lua_State *L, int idx, size_t *len)
     * }
     */
    public static MemorySegment luaW_tolstring(MemorySegment L, int idx, MemorySegment len) {
        var mh$ = luaW_tolstring.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaW_tolstring", L, idx, len);
            }
            return (MemorySegment)mh$.invokeExact(L, idx, len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaW_objlen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luawrap_h.C_INT,
            luawrap_h.C_POINTER,
            luawrap_h.C_INT
        );

        public static final MemorySegment ADDR = luawrap_h.findOrThrow("luaW_objlen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int luaW_objlen(lua_State *L, int idx)
     * }
     */
    public static FunctionDescriptor luaW_objlen$descriptor() {
        return luaW_objlen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int luaW_objlen(lua_State *L, int idx)
     * }
     */
    public static MethodHandle luaW_objlen$handle() {
        return luaW_objlen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int luaW_objlen(lua_State *L, int idx)
     * }
     */
    public static MemorySegment luaW_objlen$address() {
        return luaW_objlen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int luaW_objlen(lua_State *L, int idx)
     * }
     */
    public static int luaW_objlen(MemorySegment L, int idx) {
        var mh$ = luaW_objlen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaW_objlen", L, idx);
            }
            return (int)mh$.invokeExact(L, idx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaW_pushlstring {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            luawrap_h.C_POINTER,
            luawrap_h.C_POINTER,
            luawrap_h.C_LONG
        );

        public static final MemorySegment ADDR = luawrap_h.findOrThrow("luaW_pushlstring");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void luaW_pushlstring(lua_State *L, const char *s, size_t l)
     * }
     */
    public static FunctionDescriptor luaW_pushlstring$descriptor() {
        return luaW_pushlstring.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void luaW_pushlstring(lua_State *L, const char *s, size_t l)
     * }
     */
    public static MethodHandle luaW_pushlstring$handle() {
        return luaW_pushlstring.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void luaW_pushlstring(lua_State *L, const char *s, size_t l)
     * }
     */
    public static MemorySegment luaW_pushlstring$address() {
        return luaW_pushlstring.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void luaW_pushlstring(lua_State *L, const char *s, size_t l)
     * }
     */
    public static void luaW_pushlstring(MemorySegment L, MemorySegment s, long l) {
        var mh$ = luaW_pushlstring.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaW_pushlstring", L, s, l);
            }
            mh$.invokeExact(L, s, l);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaW_pushcclosurek {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            luawrap_h.C_POINTER,
            luawrap_h.C_POINTER,
            luawrap_h.C_POINTER,
            luawrap_h.C_INT,
            luawrap_h.C_POINTER
        );

        public static final MemorySegment ADDR = luawrap_h.findOrThrow("luaW_pushcclosurek");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void luaW_pushcclosurek(lua_State *L, lua_CFunction fn, const char *debugname, int nup, lua_Continuation cont)
     * }
     */
    public static FunctionDescriptor luaW_pushcclosurek$descriptor() {
        return luaW_pushcclosurek.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void luaW_pushcclosurek(lua_State *L, lua_CFunction fn, const char *debugname, int nup, lua_Continuation cont)
     * }
     */
    public static MethodHandle luaW_pushcclosurek$handle() {
        return luaW_pushcclosurek.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void luaW_pushcclosurek(lua_State *L, lua_CFunction fn, const char *debugname, int nup, lua_Continuation cont)
     * }
     */
    public static MemorySegment luaW_pushcclosurek$address() {
        return luaW_pushcclosurek.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void luaW_pushcclosurek(lua_State *L, lua_CFunction fn, const char *debugname, int nup, lua_Continuation cont)
     * }
     */
    public static void luaW_pushcclosurek(MemorySegment L, MemorySegment fn, MemorySegment debugname, int nup, MemorySegment cont) {
        var mh$ = luaW_pushcclosurek.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaW_pushcclosurek", L, fn, debugname, nup, cont);
            }
            mh$.invokeExact(L, fn, debugname, nup, cont);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaW_newuserdatatagged {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luawrap_h.C_POINTER,
            luawrap_h.C_POINTER,
            luawrap_h.C_LONG,
            luawrap_h.C_INT
        );

        public static final MemorySegment ADDR = luawrap_h.findOrThrow("luaW_newuserdatatagged");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *luaW_newuserdatatagged(lua_State *L, size_t sz, int tag)
     * }
     */
    public static FunctionDescriptor luaW_newuserdatatagged$descriptor() {
        return luaW_newuserdatatagged.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *luaW_newuserdatatagged(lua_State *L, size_t sz, int tag)
     * }
     */
    public static MethodHandle luaW_newuserdatatagged$handle() {
        return luaW_newuserdatatagged.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *luaW_newuserdatatagged(lua_State *L, size_t sz, int tag)
     * }
     */
    public static MemorySegment luaW_newuserdatatagged$address() {
        return luaW_newuserdatatagged.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *luaW_newuserdatatagged(lua_State *L, size_t sz, int tag)
     * }
     */
    public static MemorySegment luaW_newuserdatatagged(MemorySegment L, long sz, int tag) {
        var mh$ = luaW_newuserdatatagged.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaW_newuserdatatagged", L, sz, tag);
            }
            return (MemorySegment)mh$.invokeExact(L, sz, tag);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaW_newuserdatataggedwithmetatable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luawrap_h.C_POINTER,
            luawrap_h.C_POINTER,
            luawrap_h.C_LONG,
            luawrap_h.C_INT
        );

        public static final MemorySegment ADDR = luawrap_h.findOrThrow("luaW_newuserdatataggedwithmetatable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *luaW_newuserdatataggedwithmetatable(lua_State *L, size_t sz, int tag)
     * }
     */
    public static FunctionDescriptor luaW_newuserdatataggedwithmetatable$descriptor() {
        return luaW_newuserdatataggedwithmetatable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *luaW_newuserdatataggedwithmetatable(lua_State *L, size_t sz, int tag)
     * }
     */
    public static MethodHandle luaW_newuserdatataggedwithmetatable$handle() {
        return luaW_newuserdatataggedwithmetatable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *luaW_newuserdatataggedwithmetatable(lua_State *L, size_t sz, int tag)
     * }
     */
    public static MemorySegment luaW_newuserdatataggedwithmetatable$address() {
        return luaW_newuserdatataggedwithmetatable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *luaW_newuserdatataggedwithmetatable(lua_State *L, size_t sz, int tag)
     * }
     */
    public static MemorySegment luaW_newuserdatataggedwithmetatable(MemorySegment L, long sz, int tag) {
        var mh$ = luaW_newuserdatataggedwithmetatable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaW_newuserdatataggedwithmetatable", L, sz, tag);
            }
            return (MemorySegment)mh$.invokeExact(L, sz, tag);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaW_newuserdatadtor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luawrap_h.C_POINTER,
            luawrap_h.C_POINTER,
            luawrap_h.C_LONG,
            luawrap_h.C_POINTER
        );

        public static final MemorySegment ADDR = luawrap_h.findOrThrow("luaW_newuserdatadtor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *luaW_newuserdatadtor(lua_State *L, size_t sz, void (*dtor)(void *))
     * }
     */
    public static FunctionDescriptor luaW_newuserdatadtor$descriptor() {
        return luaW_newuserdatadtor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *luaW_newuserdatadtor(lua_State *L, size_t sz, void (*dtor)(void *))
     * }
     */
    public static MethodHandle luaW_newuserdatadtor$handle() {
        return luaW_newuserdatadtor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *luaW_newuserdatadtor(lua_State *L, size_t sz, void (*dtor)(void *))
     * }
     */
    public static MemorySegment luaW_newuserdatadtor$address() {
        return luaW_newuserdatadtor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *luaW_newuserdatadtor(lua_State *L, size_t sz, void (*dtor)(void *))
     * }
     */
    public static MemorySegment luaW_newuserdatadtor(MemorySegment L, long sz, MemorySegment dtor) {
        var mh$ = luaW_newuserdatadtor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaW_newuserdatadtor", L, sz, dtor);
            }
            return (MemorySegment)mh$.invokeExact(L, sz, dtor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaW_newbuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luawrap_h.C_POINTER,
            luawrap_h.C_POINTER,
            luawrap_h.C_LONG
        );

        public static final MemorySegment ADDR = luawrap_h.findOrThrow("luaW_newbuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *luaW_newbuffer(lua_State *L, size_t sz)
     * }
     */
    public static FunctionDescriptor luaW_newbuffer$descriptor() {
        return luaW_newbuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *luaW_newbuffer(lua_State *L, size_t sz)
     * }
     */
    public static MethodHandle luaW_newbuffer$handle() {
        return luaW_newbuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *luaW_newbuffer(lua_State *L, size_t sz)
     * }
     */
    public static MemorySegment luaW_newbuffer$address() {
        return luaW_newbuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *luaW_newbuffer(lua_State *L, size_t sz)
     * }
     */
    public static MemorySegment luaW_newbuffer(MemorySegment L, long sz) {
        var mh$ = luaW_newbuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaW_newbuffer", L, sz);
            }
            return (MemorySegment)mh$.invokeExact(L, sz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaW_gettable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luawrap_h.C_INT,
            luawrap_h.C_POINTER,
            luawrap_h.C_INT
        );

        public static final MemorySegment ADDR = luawrap_h.findOrThrow("luaW_gettable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int luaW_gettable(lua_State *L, int idx)
     * }
     */
    public static FunctionDescriptor luaW_gettable$descriptor() {
        return luaW_gettable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int luaW_gettable(lua_State *L, int idx)
     * }
     */
    public static MethodHandle luaW_gettable$handle() {
        return luaW_gettable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int luaW_gettable(lua_State *L, int idx)
     * }
     */
    public static MemorySegment luaW_gettable$address() {
        return luaW_gettable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int luaW_gettable(lua_State *L, int idx)
     * }
     */
    public static int luaW_gettable(MemorySegment L, int idx) {
        var mh$ = luaW_gettable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaW_gettable", L, idx);
            }
            return (int)mh$.invokeExact(L, idx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaW_getfield {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luawrap_h.C_INT,
            luawrap_h.C_POINTER,
            luawrap_h.C_INT,
            luawrap_h.C_POINTER
        );

        public static final MemorySegment ADDR = luawrap_h.findOrThrow("luaW_getfield");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int luaW_getfield(lua_State *L, int idx, const char *k)
     * }
     */
    public static FunctionDescriptor luaW_getfield$descriptor() {
        return luaW_getfield.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int luaW_getfield(lua_State *L, int idx, const char *k)
     * }
     */
    public static MethodHandle luaW_getfield$handle() {
        return luaW_getfield.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int luaW_getfield(lua_State *L, int idx, const char *k)
     * }
     */
    public static MemorySegment luaW_getfield$address() {
        return luaW_getfield.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int luaW_getfield(lua_State *L, int idx, const char *k)
     * }
     */
    public static int luaW_getfield(MemorySegment L, int idx, MemorySegment k) {
        var mh$ = luaW_getfield.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaW_getfield", L, idx, k);
            }
            return (int)mh$.invokeExact(L, idx, k);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaW_createtable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            luawrap_h.C_POINTER,
            luawrap_h.C_INT,
            luawrap_h.C_INT
        );

        public static final MemorySegment ADDR = luawrap_h.findOrThrow("luaW_createtable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void luaW_createtable(lua_State *L, int narr, int nrec)
     * }
     */
    public static FunctionDescriptor luaW_createtable$descriptor() {
        return luaW_createtable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void luaW_createtable(lua_State *L, int narr, int nrec)
     * }
     */
    public static MethodHandle luaW_createtable$handle() {
        return luaW_createtable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void luaW_createtable(lua_State *L, int narr, int nrec)
     * }
     */
    public static MemorySegment luaW_createtable$address() {
        return luaW_createtable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void luaW_createtable(lua_State *L, int narr, int nrec)
     * }
     */
    public static void luaW_createtable(MemorySegment L, int narr, int nrec) {
        var mh$ = luaW_createtable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaW_createtable", L, narr, nrec);
            }
            mh$.invokeExact(L, narr, nrec);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaW_settable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            luawrap_h.C_POINTER,
            luawrap_h.C_INT
        );

        public static final MemorySegment ADDR = luawrap_h.findOrThrow("luaW_settable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void luaW_settable(lua_State *L, int idx)
     * }
     */
    public static FunctionDescriptor luaW_settable$descriptor() {
        return luaW_settable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void luaW_settable(lua_State *L, int idx)
     * }
     */
    public static MethodHandle luaW_settable$handle() {
        return luaW_settable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void luaW_settable(lua_State *L, int idx)
     * }
     */
    public static MemorySegment luaW_settable$address() {
        return luaW_settable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void luaW_settable(lua_State *L, int idx)
     * }
     */
    public static void luaW_settable(MemorySegment L, int idx) {
        var mh$ = luaW_settable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaW_settable", L, idx);
            }
            mh$.invokeExact(L, idx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaW_setfield {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            luawrap_h.C_POINTER,
            luawrap_h.C_INT,
            luawrap_h.C_POINTER
        );

        public static final MemorySegment ADDR = luawrap_h.findOrThrow("luaW_setfield");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void luaW_setfield(lua_State *L, int idx, const char *k)
     * }
     */
    public static FunctionDescriptor luaW_setfield$descriptor() {
        return luaW_setfield.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void luaW_setfield(lua_State *L, int idx, const char *k)
     * }
     */
    public static MethodHandle luaW_setfield$handle() {
        return luaW_setfield.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void luaW_setfield(lua_State *L, int idx, const char *k)
     * }
     */
    public static MemorySegment luaW_setfield$address() {
        return luaW_setfield.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void luaW_setfield(lua_State *L, int idx, const char *k)
     * }
     */
    public static void luaW_setfield(MemorySegment L, int idx, MemorySegment k) {
        var mh$ = luaW_setfield.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaW_setfield", L, idx, k);
            }
            mh$.invokeExact(L, idx, k);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaW_rawsetfield {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            luawrap_h.C_POINTER,
            luawrap_h.C_INT,
            luawrap_h.C_POINTER
        );

        public static final MemorySegment ADDR = luawrap_h.findOrThrow("luaW_rawsetfield");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void luaW_rawsetfield(lua_State *L, int idx, const char *k)
     * }
     */
    public static FunctionDescriptor luaW_rawsetfield$descriptor() {
        return luaW_rawsetfield.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void luaW_rawsetfield(lua_State *L, int idx, const char *k)
     * }
     */
    public static MethodHandle luaW_rawsetfield$handle() {
        return luaW_rawsetfield.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void luaW_rawsetfield(lua_State *L, int idx, const char *k)
     * }
     */
    public static MemorySegment luaW_rawsetfield$address() {
        return luaW_rawsetfield.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void luaW_rawsetfield(lua_State *L, int idx, const char *k)
     * }
     */
    public static void luaW_rawsetfield(MemorySegment L, int idx, MemorySegment k) {
        var mh$ = luaW_rawsetfield.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaW_rawsetfield", L, idx, k);
            }
            mh$.invokeExact(L, idx, k);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaW_rawset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            luawrap_h.C_POINTER,
            luawrap_h.C_INT
        );

        public static final MemorySegment ADDR = luawrap_h.findOrThrow("luaW_rawset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void luaW_rawset(lua_State *L, int idx)
     * }
     */
    public static FunctionDescriptor luaW_rawset$descriptor() {
        return luaW_rawset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void luaW_rawset(lua_State *L, int idx)
     * }
     */
    public static MethodHandle luaW_rawset$handle() {
        return luaW_rawset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void luaW_rawset(lua_State *L, int idx)
     * }
     */
    public static MemorySegment luaW_rawset$address() {
        return luaW_rawset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void luaW_rawset(lua_State *L, int idx)
     * }
     */
    public static void luaW_rawset(MemorySegment L, int idx) {
        var mh$ = luaW_rawset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaW_rawset", L, idx);
            }
            mh$.invokeExact(L, idx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaW_rawseti {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            luawrap_h.C_POINTER,
            luawrap_h.C_INT,
            luawrap_h.C_INT
        );

        public static final MemorySegment ADDR = luawrap_h.findOrThrow("luaW_rawseti");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void luaW_rawseti(lua_State *L, int idx, int n)
     * }
     */
    public static FunctionDescriptor luaW_rawseti$descriptor() {
        return luaW_rawseti.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void luaW_rawseti(lua_State *L, int idx, int n)
     * }
     */
    public static MethodHandle luaW_rawseti$handle() {
        return luaW_rawseti.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void luaW_rawseti(lua_State *L, int idx, int n)
     * }
     */
    public static MemorySegment luaW_rawseti$address() {
        return luaW_rawseti.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void luaW_rawseti(lua_State *L, int idx, int n)
     * }
     */
    public static void luaW_rawseti(MemorySegment L, int idx, int n) {
        var mh$ = luaW_rawseti.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaW_rawseti", L, idx, n);
            }
            mh$.invokeExact(L, idx, n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaW_setmetatable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luawrap_h.C_INT,
            luawrap_h.C_POINTER,
            luawrap_h.C_INT
        );

        public static final MemorySegment ADDR = luawrap_h.findOrThrow("luaW_setmetatable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int luaW_setmetatable(lua_State *L, int objindex)
     * }
     */
    public static FunctionDescriptor luaW_setmetatable$descriptor() {
        return luaW_setmetatable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int luaW_setmetatable(lua_State *L, int objindex)
     * }
     */
    public static MethodHandle luaW_setmetatable$handle() {
        return luaW_setmetatable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int luaW_setmetatable(lua_State *L, int objindex)
     * }
     */
    public static MemorySegment luaW_setmetatable$address() {
        return luaW_setmetatable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int luaW_setmetatable(lua_State *L, int objindex)
     * }
     */
    public static int luaW_setmetatable(MemorySegment L, int objindex) {
        var mh$ = luaW_setmetatable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaW_setmetatable", L, objindex);
            }
            return (int)mh$.invokeExact(L, objindex);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaW_yield {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luawrap_h.C_INT,
            luawrap_h.C_POINTER,
            luawrap_h.C_INT
        );

        public static final MemorySegment ADDR = luawrap_h.findOrThrow("luaW_yield");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int luaW_yield(lua_State *L, int nresults)
     * }
     */
    public static FunctionDescriptor luaW_yield$descriptor() {
        return luaW_yield.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int luaW_yield(lua_State *L, int nresults)
     * }
     */
    public static MethodHandle luaW_yield$handle() {
        return luaW_yield.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int luaW_yield(lua_State *L, int nresults)
     * }
     */
    public static MemorySegment luaW_yield$address() {
        return luaW_yield.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int luaW_yield(lua_State *L, int nresults)
     * }
     */
    public static int luaW_yield(MemorySegment L, int nresults) {
        var mh$ = luaW_yield.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaW_yield", L, nresults);
            }
            return (int)mh$.invokeExact(L, nresults);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaW_break {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luawrap_h.C_INT,
            luawrap_h.C_POINTER
        );

        public static final MemorySegment ADDR = luawrap_h.findOrThrow("luaW_break");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int luaW_break(lua_State *L)
     * }
     */
    public static FunctionDescriptor luaW_break$descriptor() {
        return luaW_break.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int luaW_break(lua_State *L)
     * }
     */
    public static MethodHandle luaW_break$handle() {
        return luaW_break.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int luaW_break(lua_State *L)
     * }
     */
    public static MemorySegment luaW_break$address() {
        return luaW_break.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int luaW_break(lua_State *L)
     * }
     */
    public static int luaW_break(MemorySegment L) {
        var mh$ = luaW_break.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaW_break", L);
            }
            return (int)mh$.invokeExact(L);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaW_next {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luawrap_h.C_INT,
            luawrap_h.C_POINTER,
            luawrap_h.C_INT
        );

        public static final MemorySegment ADDR = luawrap_h.findOrThrow("luaW_next");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int luaW_next(lua_State *L, int idx)
     * }
     */
    public static FunctionDescriptor luaW_next$descriptor() {
        return luaW_next.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int luaW_next(lua_State *L, int idx)
     * }
     */
    public static MethodHandle luaW_next$handle() {
        return luaW_next.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int luaW_next(lua_State *L, int idx)
     * }
     */
    public static MemorySegment luaW_next$address() {
        return luaW_next.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int luaW_next(lua_State *L, int idx)
     * }
     */
    public static int luaW_next(MemorySegment L, int idx) {
        var mh$ = luaW_next.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaW_next", L, idx);
            }
            return (int)mh$.invokeExact(L, idx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaW_concat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            luawrap_h.C_POINTER,
            luawrap_h.C_INT
        );

        public static final MemorySegment ADDR = luawrap_h.findOrThrow("luaW_concat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void luaW_concat(lua_State *L, int n)
     * }
     */
    public static FunctionDescriptor luaW_concat$descriptor() {
        return luaW_concat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void luaW_concat(lua_State *L, int n)
     * }
     */
    public static MethodHandle luaW_concat$handle() {
        return luaW_concat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void luaW_concat(lua_State *L, int n)
     * }
     */
    public static MemorySegment luaW_concat$address() {
        return luaW_concat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void luaW_concat(lua_State *L, int n)
     * }
     */
    public static void luaW_concat(MemorySegment L, int n) {
        var mh$ = luaW_concat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaW_concat", L, n);
            }
            mh$.invokeExact(L, n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaW_setlightuserdataname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            luawrap_h.C_POINTER,
            luawrap_h.C_INT,
            luawrap_h.C_POINTER
        );

        public static final MemorySegment ADDR = luawrap_h.findOrThrow("luaW_setlightuserdataname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void luaW_setlightuserdataname(lua_State *L, int tag, const char *name)
     * }
     */
    public static FunctionDescriptor luaW_setlightuserdataname$descriptor() {
        return luaW_setlightuserdataname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void luaW_setlightuserdataname(lua_State *L, int tag, const char *name)
     * }
     */
    public static MethodHandle luaW_setlightuserdataname$handle() {
        return luaW_setlightuserdataname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void luaW_setlightuserdataname(lua_State *L, int tag, const char *name)
     * }
     */
    public static MemorySegment luaW_setlightuserdataname$address() {
        return luaW_setlightuserdataname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void luaW_setlightuserdataname(lua_State *L, int tag, const char *name)
     * }
     */
    public static void luaW_setlightuserdataname(MemorySegment L, int tag, MemorySegment name) {
        var mh$ = luaW_setlightuserdataname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaW_setlightuserdataname", L, tag, name);
            }
            mh$.invokeExact(L, tag, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaW_clonefunction {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            luawrap_h.C_POINTER,
            luawrap_h.C_INT
        );

        public static final MemorySegment ADDR = luawrap_h.findOrThrow("luaW_clonefunction");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void luaW_clonefunction(lua_State *L, int idx)
     * }
     */
    public static FunctionDescriptor luaW_clonefunction$descriptor() {
        return luaW_clonefunction.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void luaW_clonefunction(lua_State *L, int idx)
     * }
     */
    public static MethodHandle luaW_clonefunction$handle() {
        return luaW_clonefunction.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void luaW_clonefunction(lua_State *L, int idx)
     * }
     */
    public static MemorySegment luaW_clonefunction$address() {
        return luaW_clonefunction.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void luaW_clonefunction(lua_State *L, int idx)
     * }
     */
    public static void luaW_clonefunction(MemorySegment L, int idx) {
        var mh$ = luaW_clonefunction.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaW_clonefunction", L, idx);
            }
            mh$.invokeExact(L, idx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaW_cleartable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            luawrap_h.C_POINTER,
            luawrap_h.C_INT
        );

        public static final MemorySegment ADDR = luawrap_h.findOrThrow("luaW_cleartable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void luaW_cleartable(lua_State *L, int idx)
     * }
     */
    public static FunctionDescriptor luaW_cleartable$descriptor() {
        return luaW_cleartable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void luaW_cleartable(lua_State *L, int idx)
     * }
     */
    public static MethodHandle luaW_cleartable$handle() {
        return luaW_cleartable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void luaW_cleartable(lua_State *L, int idx)
     * }
     */
    public static MemorySegment luaW_cleartable$address() {
        return luaW_cleartable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void luaW_cleartable(lua_State *L, int idx)
     * }
     */
    public static void luaW_cleartable(MemorySegment L, int idx) {
        var mh$ = luaW_cleartable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaW_cleartable", L, idx);
            }
            mh$.invokeExact(L, idx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaW_clonetable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            luawrap_h.C_POINTER,
            luawrap_h.C_INT
        );

        public static final MemorySegment ADDR = luawrap_h.findOrThrow("luaW_clonetable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void luaW_clonetable(lua_State *L, int idx)
     * }
     */
    public static FunctionDescriptor luaW_clonetable$descriptor() {
        return luaW_clonetable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void luaW_clonetable(lua_State *L, int idx)
     * }
     */
    public static MethodHandle luaW_clonetable$handle() {
        return luaW_clonetable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void luaW_clonetable(lua_State *L, int idx)
     * }
     */
    public static MemorySegment luaW_clonetable$address() {
        return luaW_clonetable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void luaW_clonetable(lua_State *L, int idx)
     * }
     */
    public static void luaW_clonetable(MemorySegment L, int idx) {
        var mh$ = luaW_clonetable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaW_clonetable", L, idx);
            }
            mh$.invokeExact(L, idx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaLW_newmetatable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luawrap_h.C_INT,
            luawrap_h.C_POINTER,
            luawrap_h.C_POINTER
        );

        public static final MemorySegment ADDR = luawrap_h.findOrThrow("luaLW_newmetatable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int luaLW_newmetatable(lua_State *L, const char *tname)
     * }
     */
    public static FunctionDescriptor luaLW_newmetatable$descriptor() {
        return luaLW_newmetatable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int luaLW_newmetatable(lua_State *L, const char *tname)
     * }
     */
    public static MethodHandle luaLW_newmetatable$handle() {
        return luaLW_newmetatable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int luaLW_newmetatable(lua_State *L, const char *tname)
     * }
     */
    public static MemorySegment luaLW_newmetatable$address() {
        return luaLW_newmetatable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int luaLW_newmetatable(lua_State *L, const char *tname)
     * }
     */
    public static int luaLW_newmetatable(MemorySegment L, MemorySegment tname) {
        var mh$ = luaLW_newmetatable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaLW_newmetatable", L, tname);
            }
            return (int)mh$.invokeExact(L, tname);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaLW_tolstring {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luawrap_h.C_POINTER,
            luawrap_h.C_POINTER,
            luawrap_h.C_INT,
            luawrap_h.C_POINTER
        );

        public static final MemorySegment ADDR = luawrap_h.findOrThrow("luaLW_tolstring");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *luaLW_tolstring(lua_State *L, int idx, size_t *len)
     * }
     */
    public static FunctionDescriptor luaLW_tolstring$descriptor() {
        return luaLW_tolstring.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *luaLW_tolstring(lua_State *L, int idx, size_t *len)
     * }
     */
    public static MethodHandle luaLW_tolstring$handle() {
        return luaLW_tolstring.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *luaLW_tolstring(lua_State *L, int idx, size_t *len)
     * }
     */
    public static MemorySegment luaLW_tolstring$address() {
        return luaLW_tolstring.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *luaLW_tolstring(lua_State *L, int idx, size_t *len)
     * }
     */
    public static MemorySegment luaLW_tolstring(MemorySegment L, int idx, MemorySegment len) {
        var mh$ = luaLW_tolstring.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaLW_tolstring", L, idx, len);
            }
            return (MemorySegment)mh$.invokeExact(L, idx, len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaLW_findtable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luawrap_h.C_POINTER,
            luawrap_h.C_POINTER,
            luawrap_h.C_INT,
            luawrap_h.C_POINTER,
            luawrap_h.C_INT
        );

        public static final MemorySegment ADDR = luawrap_h.findOrThrow("luaLW_findtable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *luaLW_findtable(lua_State *L, int idx, const char *fname, int szhint)
     * }
     */
    public static FunctionDescriptor luaLW_findtable$descriptor() {
        return luaLW_findtable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *luaLW_findtable(lua_State *L, int idx, const char *fname, int szhint)
     * }
     */
    public static MethodHandle luaLW_findtable$handle() {
        return luaLW_findtable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *luaLW_findtable(lua_State *L, int idx, const char *fname, int szhint)
     * }
     */
    public static MemorySegment luaLW_findtable$address() {
        return luaLW_findtable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *luaLW_findtable(lua_State *L, int idx, const char *fname, int szhint)
     * }
     */
    public static MemorySegment luaLW_findtable(MemorySegment L, int idx, MemorySegment fname, int szhint) {
        var mh$ = luaLW_findtable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaLW_findtable", L, idx, fname, szhint);
            }
            return (MemorySegment)mh$.invokeExact(L, idx, fname, szhint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaLW_typename {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luawrap_h.C_POINTER,
            luawrap_h.C_POINTER,
            luawrap_h.C_INT
        );

        public static final MemorySegment ADDR = luawrap_h.findOrThrow("luaLW_typename");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *luaLW_typename(lua_State *L, int idx)
     * }
     */
    public static FunctionDescriptor luaLW_typename$descriptor() {
        return luaLW_typename.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *luaLW_typename(lua_State *L, int idx)
     * }
     */
    public static MethodHandle luaLW_typename$handle() {
        return luaLW_typename.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *luaLW_typename(lua_State *L, int idx)
     * }
     */
    public static MemorySegment luaLW_typename$address() {
        return luaLW_typename.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *luaLW_typename(lua_State *L, int idx)
     * }
     */
    public static MemorySegment luaLW_typename(MemorySegment L, int idx) {
        var mh$ = luaLW_typename.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaLW_typename", L, idx);
            }
            return (MemorySegment)mh$.invokeExact(L, idx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaLW_typeerror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            luawrap_h.C_POINTER,
            luawrap_h.C_INT,
            luawrap_h.C_POINTER
        );

        public static final MemorySegment ADDR = luawrap_h.findOrThrow("luaLW_typeerror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void luaLW_typeerror(lua_State *L, int narg, const char *tname)
     * }
     */
    public static FunctionDescriptor luaLW_typeerror$descriptor() {
        return luaLW_typeerror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void luaLW_typeerror(lua_State *L, int narg, const char *tname)
     * }
     */
    public static MethodHandle luaLW_typeerror$handle() {
        return luaLW_typeerror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void luaLW_typeerror(lua_State *L, int narg, const char *tname)
     * }
     */
    public static MemorySegment luaLW_typeerror$address() {
        return luaLW_typeerror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void luaLW_typeerror(lua_State *L, int narg, const char *tname)
     * }
     */
    public static void luaLW_typeerror(MemorySegment L, int narg, MemorySegment tname) {
        var mh$ = luaLW_typeerror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaLW_typeerror", L, narg, tname);
            }
            mh$.invokeExact(L, narg, tname);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaLW_argerror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            luawrap_h.C_POINTER,
            luawrap_h.C_INT,
            luawrap_h.C_POINTER
        );

        public static final MemorySegment ADDR = luawrap_h.findOrThrow("luaLW_argerror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void luaLW_argerror(lua_State *L, int narg, const char *extramsg)
     * }
     */
    public static FunctionDescriptor luaLW_argerror$descriptor() {
        return luaLW_argerror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void luaLW_argerror(lua_State *L, int narg, const char *extramsg)
     * }
     */
    public static MethodHandle luaLW_argerror$handle() {
        return luaLW_argerror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void luaLW_argerror(lua_State *L, int narg, const char *extramsg)
     * }
     */
    public static MemorySegment luaLW_argerror$address() {
        return luaLW_argerror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void luaLW_argerror(lua_State *L, int narg, const char *extramsg)
     * }
     */
    public static void luaLW_argerror(MemorySegment L, int narg, MemorySegment extramsg) {
        var mh$ = luaLW_argerror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaLW_argerror", L, narg, extramsg);
            }
            mh$.invokeExact(L, narg, extramsg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaLW_checkboolean {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luawrap_h.C_INT,
            luawrap_h.C_POINTER,
            luawrap_h.C_INT
        );

        public static final MemorySegment ADDR = luawrap_h.findOrThrow("luaLW_checkboolean");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int luaLW_checkboolean(lua_State *L, int narg)
     * }
     */
    public static FunctionDescriptor luaLW_checkboolean$descriptor() {
        return luaLW_checkboolean.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int luaLW_checkboolean(lua_State *L, int narg)
     * }
     */
    public static MethodHandle luaLW_checkboolean$handle() {
        return luaLW_checkboolean.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int luaLW_checkboolean(lua_State *L, int narg)
     * }
     */
    public static MemorySegment luaLW_checkboolean$address() {
        return luaLW_checkboolean.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int luaLW_checkboolean(lua_State *L, int narg)
     * }
     */
    public static int luaLW_checkboolean(MemorySegment L, int narg) {
        var mh$ = luaLW_checkboolean.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaLW_checkboolean", L, narg);
            }
            return (int)mh$.invokeExact(L, narg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaLW_checkudata {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luawrap_h.C_POINTER,
            luawrap_h.C_POINTER,
            luawrap_h.C_INT,
            luawrap_h.C_POINTER
        );

        public static final MemorySegment ADDR = luawrap_h.findOrThrow("luaLW_checkudata");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *luaLW_checkudata(lua_State *L, int ud, const char *tname)
     * }
     */
    public static FunctionDescriptor luaLW_checkudata$descriptor() {
        return luaLW_checkudata.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *luaLW_checkudata(lua_State *L, int ud, const char *tname)
     * }
     */
    public static MethodHandle luaLW_checkudata$handle() {
        return luaLW_checkudata.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *luaLW_checkudata(lua_State *L, int ud, const char *tname)
     * }
     */
    public static MemorySegment luaLW_checkudata$address() {
        return luaLW_checkudata.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *luaLW_checkudata(lua_State *L, int ud, const char *tname)
     * }
     */
    public static MemorySegment luaLW_checkudata(MemorySegment L, int ud, MemorySegment tname) {
        var mh$ = luaLW_checkudata.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaLW_checkudata", L, ud, tname);
            }
            return (MemorySegment)mh$.invokeExact(L, ud, tname);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
}

